# 日志框架的历史

## 一、日志框架的分类

  - 门面型日志框架：

  1. JCL：　　Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging
  2. SLF4J：  是一套简易Java日志门面，**本身并无日志的实现**。（Simple Logging Facade for Java，缩写Slf4j）

  - 记录型日志框架:

  1. JUL：　　JDK中的日志记录工具，也常称为JDKLog、jdk-logging，自Java1.4以来的官方日志实现。
  2. Log4j：　 一个具体的日志实现框架。
  3. Log4j2：  一个具体的日志实现框架，是LOG4J1的下一个版本，与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。
  4. Logback：一个具体的日志实现框架，和Slf4j是同一个作者，但其性能更好。

  　　　　　　　　　　　　　　![img](https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801222005588-1535811596.png)

## 二、发展历程

要搞清楚它们的关系，就要从它们是在什么情况下产生的说起。我们按照时间的先后顺序来介绍。

### Log4j

  在JDK 1.3及以前，Java打日志依赖System.out.println(), System.err.println()或者e.printStackTrace()，Debug日志被写到STDOUT流，错误日志被写到STDERR流。这样打日志有一个非常大的缺陷，即无法定制化，且日志粒度不够细。
  于是， Gülcü 于2001年发布了Log4j，后来成为Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，它定义的Logger、Appender、Level等概念如今已经被广泛使用。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。

### J.U.L

受Logj启发，Sun在Java1.4版本中引入了java.util.logging，但是j.u.l功能远不如log4j完善，开发者需要自己编写Appenders（Sun称之为Handlers），且只有两个Handlers可用（Console和File），j.u.l在Java1.5以后性能和可用性才有所提升。

JUL 全称 java.util.logging.Logger，JDK 自带的日志系统，从 JDK1.4 就有了。因为 log4j 的存在，这个 logger 一直沉默着，其实在一些测试性的代码中，jdk 自带的 logger 比 log4j 更方便。JUL 是自带具体实现的，与 log4j、logback 等类似，而不是像 JCL、slf4j 那样的日志接口封装。

```
import java.util.logging.Level;
import java.util.logging.Logger;

private static final Logger LOGGER = Logger.getLogger(MyClass.class.getName());
```

- 相同名字的 Logger 对象全局只有一个；
- 一般使用圆点分隔的层次命名空间来命名 Logger；Logger 名称可以是任意的字符串，但是它们一般应该基于被记录组件的包名或类名，如 java.net 或 javax.swing；
- 配置文件默认使用 jre/lib/logging.properties，日志级别默认为 INFO；
- 可以通过系统属性 java.util.logging.config.file 指定路径覆盖系统默认文件；
- 日志级别由高到低依次为：SEVERE（严重）、WARNING（警告）、INFO（信息）、CONFIG（配置）、FINE（详细）、FINER（较详细）、FINEST（非常详细）。另外还有两个全局开关：OFF「关闭日志记录」和 ALL「启用所有消息日志记录」。
- 《logging.properties》文件中，默认日志级别可以通过.level= ALL 来控制，也可以基于层次命名空间来控制，按照 Logger 名字进行前缀匹配，匹配度最高的优先采用；日志级别只认大写；
- JUL 通过 handler 来完成实际的日志输出，可以通过配置文件指定一个或者多个 hanlder，多个 handler 之间使用逗号分隔；handler 上也有一个日志级别，作为该 handler 可以接收的日志最低级别，低于该级别的日志，将不进行实际的输出；handler 上可以绑定日志格式化器，比如 java.util.logging.ConsoleHandler 就是使用的 String.format 来支持的；

配置文件示例：

```
handlers= java.util.logging.ConsoleHandler

.level= ALL
com.suian.logger.jul.xxx.level = CONFIG
com.suian.logger.jul.xxx.demo2.level = FINE
com.suian.logger.jul.xxx.demo3.level = FINER

java.util.logging.ConsoleHandler.level = ALL
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
java.util.logging.SimpleFormatter.format=%1$tF %1$tT [%4$s] %3$s -  %5$s %n
```

### JCL（commons-logging）

  由于项目的日志打印必然选择两个框架中至少一个，这时候，Apache的JCL（commons-logging）诞生了。JCL 是一个Log Facade，只提供 Log API，不提供实现，然后有 Adapter 来使用 Log4j 或者 JUL 作为Log Implementation。
  在程序中日志创建和记录都是用JCL中的接口，在真正运行时，会看当前ClassPath中有什么实现，如果有Log4j 就是用 Log4j, 如果啥都没有就是用 JDK 的 JUL。
  这样，在你的项目中，还有第三方的项目中，大家记录日志都使用 JCL 的接口，然后最终运行程序时，可以按照自己的需求(或者喜好)来选择使用合适的Log Implementation。如果用Log4j, 就添加 Log4j 的jar包进去，然后写一个 Log4j 的配置文件；如果喜欢用JUL，就只需要写个 JUL 的配置文件。如果有其他的新的日志库出现，也只需要它提供一个Adapter，运行的时候把这个日志库的 jar 包加进去。
  不过，commons-logging对Log4j和j.u.l的配置问题兼容的并不好，使用commons-loggings还可能会遇到类加载问题，导致NoClassDefFoundError的错误出现。

  　　　　　　　　　　　　　　　　　　　　　　　　![img](https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801215840541-1005764017.png)

  到这个时候一切看起来都很简单，很美好。接口和实现做了良好的分离，在统一的JCL之下，不改变任何代码，就可以通过配置就换用功能更强大，或者性能更好的日志库实现。

  这种简单美好一直持续到SLF4J出现。

### SLF4J & Logback

  SLF4J（Simple Logging Facade for Java）和 Logback 也是Gülcü 创立的项目，目的是为了提供更高性能的实现。
  从设计模式的角度说，SLF4J 是用来在log和代码层之间起到门面作用，类似于 JCL 的 Log Facade。对于用户来说只要使用SLF4J提供的接口，即可隐藏日志的具体实现，SLF4J提供的核心API是一些接口和一个LoggerFactory的工厂类，用户只需按照它提供的统一纪录日志接口，最终日志的格式、纪录级别、输出方式等可通过具体日志系统的配置来实现，因此可以灵活的切换日志系统。

  Logback是log4j的升级版，当前分为三个目标模块：

  - logback-core：核心模块，是其它两个模块的基础模块
  - logback-classic：是log4j的一个改良版本，同时完整实现 SLF4J API 使你可以很方便地更换成其它日记系统如log4j 或 JDK14 Logging
  - logback-access：访问模块与Servlet容器集成提供通过Http来访问日记的功能，是logback不可或缺的组成部分

  Logback相较于log4j有更多的优点：

  - 更快的执行速度
  - 更充分的测试
  - logback-classic 非常自然的实现了SLF4J
  - 使用XML配置文件或者Groovy
  - 自动重新载入配置文件
  - 优雅地从I/O错误中恢复
  - 自动清除旧的日志归档文件
  - 自动压缩归档日志文件
  - 谨慎模式
  - Lilith
  - 配置文件中的条件处理
  - 更丰富的过滤

  更详细的解释参见官网：[https://logback.qos.ch/reasonsToSwitch.html](https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Flink.jianshu.com%2F%3Ft%3Dhttps%3A%2F%2Flogback.qos.ch%2FreasonsToSwitch.html)

  到这里，你可能会问：Apache 已经有了个JCL，用来做各种Log lib统一的接口，如果 Gülcü 要搞一个更好的 Log 实现的话，直接写一个实现就好了，为啥还要搞一个和SLF4J呢?

  原因是Gülcü 认为 JCL 的 API 设计得不好，容易让使用者写出性能有问题的代码。关于这点，你可以参考这篇文章获得更详细的介绍：[https://zhuanlan.zhihu.com/p/24272450](https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Flink.jianshu.com%2F%3Ft%3Dhttps%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F24272450)

  现在事情就变复杂了。我们有了两个流行的 Log Facade，以及三个流行的 Log Implementation。Gülcü 是个追求完美的人，他决定让这些Log之间都能够方便的互相替换，所以做了各种 Adapter 和 Bridge 来连接:

  　　　　　　　　　　　　　　![img](https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801220018444-1557580371.png)

  可以看到甚至 Log4j 和 JUL 都可以桥接到SLF4J，再通过 SLF4J 适配到到 Logback！需要注意的是不能有循环的桥接，比如下面这些依赖就不能同时存在:

  - jcl-over-slf4j 和 slf4j-jcl
  - log4j-over-slf4j 和 slf4j-log4j12
  - jul-to-slf4j 和 slf4j-jdk14

  然而，事情在变得更麻烦！

  Log4j2

  现在有了更好的 SLF4J 和 Logback，慢慢取代JCL 和 Log4j ，事情到这里总该大统一圆满结束了吧。然而维护 Log4j 的人不这样想，他们不想坐视用户一点点被 SLF4J / Logback 蚕食，继而搞出了 Log4j2。

  Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。

  现在好了，我们有了三个流行的Log 接口和四个流行的Log实现，如果画出桥接关系的图来回事什么样子呢?

  　　　　　　　　　　　　![img](https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801220108556-715466336.png)
  看到这里是不是感觉有点晕呢？是的，我也有这种感觉。同样，在添加依赖的时候，要小心不要有循环依赖。